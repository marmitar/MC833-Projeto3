"""
This type stub file was generated by pyright.
"""

from collections.abc import Generator
from types import ModuleType
from typing import TYPE_CHECKING
from ._typing import Array
from typing_extensions import TypeIs

"""Helper functions used by `array_api_extra/_funcs.py`."""
if TYPE_CHECKING:
    ...
__all__ = ["asarrays", "eager_shape", "in1d", "is_python_scalar", "mean", "meta_namespace"]
def in1d(x1: Array, x2: Array, /, *, assume_unique: bool = ..., invert: bool = ..., xp: ModuleType | None = ...) -> Array:
    """
    Check whether each element of an array is also present in a second array.

    Returns a boolean array the same length as `x1` that is True
    where an element of `x1` is in `x2` and False otherwise.

    This function has been adapted using the original implementation
    present in numpy:
    https://github.com/numpy/numpy/blob/v1.26.0/numpy/lib/arraysetops.py#L524-L758
    """
    ...

def mean(x: Array, /, *, axis: int | tuple[int, ...] | None = ..., keepdims: bool = ..., xp: ModuleType | None = ...) -> Array:
    """
    Complex mean, https://github.com/data-apis/array-api/issues/846.
    """
    ...

def is_python_scalar(x: object) -> TypeIs[complex]:
    """Return True if `x` is a Python scalar, False otherwise."""
    ...

def asarrays(a: Array | complex, b: Array | complex, xp: ModuleType) -> tuple[Array, Array]:
    """
    Ensure both `a` and `b` are arrays.

    If `b` is a python scalar, it is converted to the same dtype as `a`, and vice versa.

    Behavior is not specified when mixing a Python ``float`` and an array with an
    integer data type; this may give ``float32``, ``float64``, or raise an exception.
    Behavior is implementation-specific.

    Similarly, behavior is not specified when mixing a Python ``complex`` and an array
    with a real-valued data type; this may give ``complex64``, ``complex128``, or raise
    an exception. Behavior is implementation-specific.

    Parameters
    ----------
    a, b : Array | int | float | complex | bool
        Input arrays or scalars. At least one must be an array.
    xp : array_namespace, optional
        The standard-compatible namespace for `x`. Default: infer.

    Returns
    -------
    Array, Array
        The input arrays, possibly converted to arrays if they were scalars.

    See Also
    --------
    mixing-arrays-with-python-scalars : Array API specification for the behavior.
    """
    ...

def ndindex(*x: int) -> Generator[tuple[int, ...]]:
    """
    Generate all N-dimensional indices for a given array shape.

    Given the shape of an array, an ndindex instance iterates over the N-dimensional
    index of the array. At each iteration a tuple of indices is returned, the last
    dimension is iterated over first.

    This has an identical API to numpy.ndindex.

    Parameters
    ----------
    *x : int
        The shape of the array.
    """
    ...

def eager_shape(x: Array, /) -> tuple[int, ...]:
    """
    Return shape of an array. Raise if shape is not fully defined.

    Parameters
    ----------
    x : Array
        Input array.

    Returns
    -------
    tuple[int, ...]
        Shape of the array.
    """
    ...

def meta_namespace(*arrays: Array | complex | None, xp: ModuleType | None = ...) -> ModuleType:
    """
    Get the namespace of Dask chunks.

    On all other backends, just return the namespace of the arrays.

    Parameters
    ----------
    *arrays : Array | int | float | complex | bool | None
        Input arrays.
    xp : array_namespace, optional
        The standard-compatible namespace for the input arrays. Default: infer.

    Returns
    -------
    array_namespace
        If xp is Dask, the namespace of the Dask chunks;
        otherwise, the namespace of the arrays.
    """
    ...
