"""
This type stub file was generated by pyright.
"""

"""
This models contains the Kernels for Kernel smoothing.

Hopefully in the future they may be reused/extended for other kernel based
method

References:
----------

Pointwise Kernel Confidence Bounds
(smoothconf)
http://fedc.wiwi.hu-berlin.de/xplore/ebooks/html/anr/anrhtmlframe62.html
"""
class NdKernel:
    """Generic N-dimensial kernel

    Parameters
    ----------
    n : int
        The number of series for kernel estimates
    kernels : list
        kernels

    Can be constructed from either
    a) a list of n kernels which will be treated as
    indepent marginals on a gaussian copula (specified by H)
    or b) a single univariate kernel which will be applied radially to the
    mahalanobis distance defined by H.

    In the case of the Gaussian these are both equivalent, and the second constructiong
    is prefered.
    """
    def __init__(self, n, kernels=..., H=...) -> None:
        ...

    def getH(self): # -> matrix[_2D, Incomplete]:
        """Getter for kernel bandwidth, H"""
        ...

    def setH(self, value): # -> None:
        """Setter for kernel bandwidth, H"""
        ...

    H = ...
    def density(self, xs, x): # -> floating[Any] | float:
        ...

    def __call__(self, x): # -> object | None:
        """
        This simply returns the value of the kernel function at x

        Does the same as weight if the function is normalised
        """
        ...



class CustomKernel:
    """
    Generic 1D Kernel object.
    Can be constructed by selecting a standard named Kernel,
    or providing a lambda expression and domain.
    The domain allows some algorithms to run faster for finite domain kernels.
    """
    def __init__(self, shape, h=..., domain=..., norm=...) -> None:
        """
        shape should be a function taking and returning numeric type.

        For sanity it should always return positive or zero but this is not
        enforced in case you want to do weird things. Bear in mind that the
        statistical tests etc. may not be valid for non-positive kernels.

        The bandwidth of the kernel is supplied as h.

        You may specify a domain as a list of 2 values [min, max], in which case
        kernel will be treated as zero outside these values. This will speed up
        calculation.

        You may also specify the normalisation constant for the supplied Kernel.
        If you do this number will be stored and used as the normalisation
        without calculation.  It is recommended you do this if you know the
        constant, to speed up calculation.  In particular if the shape function
        provided is already normalised you should provide norm = 1.0.

        Warning: I think several calculations assume that the kernel is
        normalized. No tests for non-normalized kernel.
        """
        ...

    def geth(self): # -> float:
        """Getter for kernel bandwidth, h"""
        ...

    def seth(self, value): # -> None:
        """Setter for kernel bandwidth, h"""
        ...

    h = ...
    def in_domain(self, xs, ys, x): # -> tuple[Any, Any] | tuple[tuple[Any, ...], tuple[Any, ...]] | tuple[list[Any], list[Any]]:
        """
        Returns the filtered (xs, ys) based on the Kernel domain centred on x
        """
        ...

    def density(self, xs, x): # -> Any | float:
        """Returns the kernel density estimate for point x based on x-values
        xs
        """
        ...

    def density_var(self, density, nobs):
        """approximate pointwise variance for kernel density

        not verified

        Parameters
        ----------
        density : array_lie
            pdf of the kernel density
        nobs : int
            number of observations used in the KDE estimation

        Returns
        -------
        kde_var : ndarray
            estimated variance of the density estimate

        Notes
        -----
        This uses the asymptotic normal approximation to the distribution of
        the density estimate.
        """
        ...

    def density_confint(self, density, nobs, alpha=...): # -> NDArray[Any]:
        """approximate pointwise confidence interval for kernel density

        The confidence interval is centered at the estimated density and
        ignores the bias of the density estimate.

        not verified

        Parameters
        ----------
        density : array_lie
            pdf of the kernel density
        nobs : int
            number of observations used in the KDE estimation

        Returns
        -------
        conf_int : ndarray
            estimated confidence interval of the density estimate, lower bound
            in first column and upper bound in second column

        Notes
        -----
        This uses the asymptotic normal approximation to the distribution of
        the density estimate. The lower bound can be negative for density
        values close to zero.
        """
        ...

    def smooth(self, xs, ys, x): # -> float:
        """Returns the kernel smoothing estimate for point x based on x-values
        xs and y-values ys.
        Not expected to be called by the user.
        """
        ...

    def smoothvar(self, xs, ys, x): # -> float:
        """Returns the kernel smoothing estimate of the variance at point x.
        """
        ...

    def smoothconf(self, xs, ys, x, alpha=...): # -> tuple[Any, Any | float, Any] | tuple[float, float, float]:
        """Returns the kernel smoothing estimate with confidence 1sigma bounds
        """
        ...

    @property
    def L2Norm(self):
        """Returns the integral of the square of the kernal from -inf to inf"""
        ...

    @property
    def norm_const(self):
        """
        Normalising constant for kernel (integral from -inf to inf)
        """
        ...

    @property
    def kernel_var(self):
        """Returns the second moment of the kernel"""
        ...

    def moments(self, n): # -> Literal[0] | None:
        ...

    @property
    def normal_reference_constant(self):
        """
        Constant used for silverman normal reference asymtotic bandwidth
        calculation.

        C  = 2((pi^(1/2)*(nu!)^3 R(k))/(2nu(2nu)!kap_nu(k)^2))^(1/(2nu+1))
        nu = kernel order
        kap_nu = nu'th moment of kernel
        R = kernel roughness (square of L^2 norm)

        Note: L2Norm property returns square of norm.
        """
        ...

    def weight(self, x):
        """This returns the normalised weight at distance x"""
        ...

    def __call__(self, x): # -> object:
        """
        This simply returns the value of the kernel function at x

        Does the same as weight if the function is normalised
        """
        ...



class Uniform(CustomKernel):
    def __init__(self, h=...) -> None:
        ...



class Triangular(CustomKernel):
    def __init__(self, h=...) -> None:
        ...



class Epanechnikov(CustomKernel):
    def __init__(self, h=...) -> None:
        ...



class Biweight(CustomKernel):
    def __init__(self, h=...) -> None:
        ...

    def smooth(self, xs, ys, x): # -> Any | float:
        """Returns the kernel smoothing estimate for point x based on x-values
        xs and y-values ys.
        Not expected to be called by the user.

        Special implementation optimized for Biweight.
        """
        ...

    def smoothvar(self, xs, ys, x): # -> Any | float:
        """
        Returns the kernel smoothing estimate of the variance at point x.
        """
        ...

    def smoothconf_(self, xs, ys, x): # -> tuple[Any, Any | float, Any] | tuple[float, float, float]:
        """Returns the kernel smoothing estimate with confidence 1sigma bounds
        """
        ...



class Triweight(CustomKernel):
    def __init__(self, h=...) -> None:
        ...



class Gaussian(CustomKernel):
    """
    Gaussian (Normal) Kernel

    K(u) = 1 / (sqrt(2*pi)) exp(-0.5 u**2)
    """
    def __init__(self, h=...) -> None:
        ...

    def smooth(self, xs, ys, x): # -> Any:
        """Returns the kernel smoothing estimate for point x based on x-values
        xs and y-values ys.
        Not expected to be called by the user.

        Special implementation optimized for Gaussian.
        """
        ...



class Cosine(CustomKernel):
    """
    Cosine Kernel

    K(u) = pi/4 cos(0.5 * pi * u) between -1.0 and 1.0
    """
    def __init__(self, h=...) -> None:
        ...



class Cosine2(CustomKernel):
    """
    Cosine2 Kernel

    K(u) = 1 + cos(2 * pi * u) between -0.5 and 0.5

    Note: this  is the same Cosine kernel that Stata uses
    """
    def __init__(self, h=...) -> None:
        ...



class Tricube(CustomKernel):
    """
    Tricube Kernel

    K(u) = 0.864197530864 * (1 - abs(x)**3)**3 between -1.0 and 1.0
    """
    def __init__(self, h=...) -> None:
        ...
