"""
This type stub file was generated by pyright.
"""

"""Asymmetric kernels for R+ and unit interval

References
----------

.. [1] Bouezmarni, Taoufik, and Olivier Scaillet. 2005. “Consistency of
   Asymmetric Kernel Density Estimators and Smoothed Histograms with
   Application to Income Data.” Econometric Theory 21 (2): 390–412.

.. [2] Chen, Song Xi. 1999. “Beta Kernel Estimators for Density Functions.”
   Computational Statistics & Data Analysis 31 (2): 131–45.
   https://doi.org/10.1016/S0167-9473(99)00010-9.

.. [3] Chen, Song Xi. 2000. “Probability Density Function Estimation Using
   Gamma Kernels.”
   Annals of the Institute of Statistical Mathematics 52 (3): 471–80.
   https://doi.org/10.1023/A:1004165218295.

.. [4] Jin, Xiaodong, and Janusz Kawczak. 2003. “Birnbaum-Saunders and
   Lognormal Kernel Estimators for Modelling Durations in High Frequency
   Financial Data.” Annals of Economics and Finance 4: 103–24.

.. [5] Micheaux, Pierre Lafaye de, and Frédéric Ouimet. 2020. “A Study of Seven
   Asymmetric Kernels for the Estimation of Cumulative Distribution Functions,”
   November. https://arxiv.org/abs/2011.14893v1.

.. [6] Mombeni, Habib Allah, B Masouri, and Mohammad Reza Akhoond. 2019.
   “Asymmetric Kernels for Boundary Modification in Distribution Function
   Estimation.” REVSTAT, 1–27.

.. [7] Scaillet, O. 2004. “Density Estimation Using Inverse and Reciprocal
   Inverse Gaussian Kernels.”
   Journal of Nonparametric Statistics 16 (1–2): 217–26.
   https://doi.org/10.1080/10485250310001624819.


Created on Mon Mar  8 11:12:24 2021

Author: Josef Perktold
License: BSD-3

"""
doc_params = ...
def pdf_kernel_asym(x, sample, bw, kernel_type, weights=..., batch_size=...): # -> Any | NDArray[float64]:
    """Density estimate based on asymmetric kernel.

    Parameters
    ----------
    x : array_like, float
        Points for which density is evaluated. ``x`` can be scalar or 1-dim.
    sample : ndarray, 1-d
        Sample from which kernel estimate is computed.
    bw : float
        Bandwidth parameter, there is currently no default value for it.
    kernel_type : str or callable
        Kernel name or kernel function.
        Currently supported kernel names are "beta", "beta2", "gamma",
        "gamma2", "bs", "invgamma", "invgauss", "lognorm", "recipinvgauss" and
        "weibull".
    weights : None or ndarray
        If weights is not None, then kernel for sample points are weighted
        by it. No weights corresponds to uniform weighting of each component
        with 1 / nobs, where nobs is the size of `sample`.
    batch_size : float
        If x is an 1-dim array, then points can be evaluated in vectorized
        form. To limit the amount of memory, a loop can work in batches.
        The number of batches is determined so that the intermediate array
        sizes are limited by

        ``np.size(batch) * len(sample) < batch_size * 1000``.

        Default is to have at most 10000 elements in intermediate arrays.

    Returns
    -------
    pdf : float or ndarray
        Estimate of pdf at points x. ``pdf`` has the same size or shape as x.
    """
    ...

def cdf_kernel_asym(x, sample, bw, kernel_type, weights=..., batch_size=...): # -> Any | NDArray[float64]:
    """Estimate of cumulative distribution based on asymmetric kernel.

    Parameters
    ----------
    x : array_like, float
        Points for which density is evaluated. ``x`` can be scalar or 1-dim.
    sample : ndarray, 1-d
        Sample from which kernel estimate is computed.
    bw : float
        Bandwidth parameter, there is currently no default value for it.
    kernel_type : str or callable
        Kernel name or kernel function.
        Currently supported kernel names are "beta", "beta2", "gamma",
        "gamma2", "bs", "invgamma", "invgauss", "lognorm", "recipinvgauss" and
        "weibull".
    weights : None or ndarray
        If weights is not None, then kernel for sample points are weighted
        by it. No weights corresponds to uniform weighting of each component
        with 1 / nobs, where nobs is the size of `sample`.
    batch_size : float
        If x is an 1-dim array, then points can be evaluated in vectorized
        form. To limit the amount of memory, a loop can work in batches.
        The number of batches is determined so that the intermediate array
        sizes are limited by

        ``np.size(batch) * len(sample) < batch_size * 1000``.

        Default is to have at most 10000 elements in intermediate arrays.

    Returns
    -------
    cdf : float or ndarray
        Estimate of cdf at points x. ``cdf`` has the same size or shape as x.
    """
    ...

def kernel_pdf_beta(x, sample, bw): # -> ndarray[_AnyShape, dtype[Any]] | ndarray[tuple[()], dtype[Any]]:
    ...

def kernel_cdf_beta(x, sample, bw): # -> ndarray[_AnyShape, dtype[Any]] | ndarray[tuple[()], dtype[Any]]:
    ...

def kernel_pdf_beta2(x, sample, bw): # -> ndarray[_AnyShape, dtype[Any]] | ndarray[tuple[()], dtype[Any]]:
    ...

def kernel_cdf_beta2(x, sample, bw): # -> ndarray[_AnyShape, dtype[Any]] | ndarray[tuple[()], dtype[Any]]:
    ...

def kernel_pdf_gamma(x, sample, bw): # -> ndarray[_AnyShape, dtype[Any]] | ndarray[tuple[()], dtype[Any]]:
    ...

def kernel_cdf_gamma(x, sample, bw): # -> ndarray[_AnyShape, dtype[Any]] | ndarray[tuple[()], dtype[Any]]:
    ...

def kernel_pdf_gamma2(x, sample, bw): # -> ndarray[_AnyShape, dtype[Any]] | ndarray[tuple[()], dtype[Any]]:
    ...

def kernel_cdf_gamma2(x, sample, bw): # -> ndarray[_AnyShape, dtype[Any]] | ndarray[tuple[()], dtype[Any]]:
    ...

def kernel_pdf_invgamma(x, sample, bw): # -> ndarray[_AnyShape, dtype[Any]] | ndarray[tuple[()], dtype[Any]]:
    ...

def kernel_cdf_invgamma(x, sample, bw): # -> ndarray[_AnyShape, dtype[Any]] | ndarray[tuple[()], dtype[Any]]:
    ...

def kernel_pdf_invgauss(x, sample, bw): # -> ndarray[_AnyShape, dtype[Any]] | ndarray[tuple[()], dtype[Any]]:
    ...

def kernel_pdf_invgauss_(x, sample, bw): # -> Any:
    """Inverse gaussian kernel density, explicit formula.

    Scaillet 2004
    """
    ...

def kernel_cdf_invgauss(x, sample, bw): # -> ndarray[_AnyShape, dtype[Any]] | ndarray[tuple[()], dtype[Any]]:
    ...

def kernel_pdf_recipinvgauss(x, sample, bw): # -> ndarray[_AnyShape, dtype[Any]] | ndarray[tuple[()], dtype[Any]]:
    ...

def kernel_pdf_recipinvgauss_(x, sample, bw): # -> Any:
    """Reciprocal inverse gaussian kernel density, explicit formula.

    Scaillet 2004
    """
    ...

def kernel_cdf_recipinvgauss(x, sample, bw): # -> ndarray[_AnyShape, dtype[Any]] | ndarray[tuple[()], dtype[Any]]:
    ...

def kernel_pdf_bs(x, sample, bw): # -> ndarray[_AnyShape, dtype[Any]] | ndarray[tuple[()], dtype[Any]]:
    ...

def kernel_cdf_bs(x, sample, bw): # -> ndarray[_AnyShape, dtype[Any]] | ndarray[tuple[()], dtype[Any]]:
    ...

def kernel_pdf_lognorm(x, sample, bw): # -> ndarray[_AnyShape, dtype[Any]] | ndarray[tuple[()], dtype[Any]]:
    ...

def kernel_cdf_lognorm(x, sample, bw): # -> ndarray[_AnyShape, dtype[Any]] | ndarray[tuple[()], dtype[Any]]:
    ...

def kernel_pdf_lognorm_(x, sample, bw):
    """Log-normal kernel for density, pdf, estimation, explicit formula.

    Jin, Kawczak 2003
    """
    ...

def kernel_pdf_weibull(x, sample, bw): # -> ndarray[_AnyShape, dtype[Any]] | ndarray[tuple[()], dtype[Any]]:
    ...

def kernel_cdf_weibull(x, sample, bw): # -> ndarray[_AnyShape, dtype[Any]] | ndarray[tuple[()], dtype[Any]]:
    ...

kernel_dict_cdf = ...
kernel_dict_pdf = ...
