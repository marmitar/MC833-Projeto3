"""
This type stub file was generated by pyright.
"""

"""Tools for working with groups

This provides several functions to work with groups and a Group class that
keeps track of the different representations and has methods to work more
easily with groups.


Author: Josef Perktold,
Author: Nathaniel Smith, recipe for sparse_dummies on scipy user mailing list

Created on Tue Nov 29 15:44:53 2011 : sparse_dummies
Created on Wed Nov 30 14:28:24 2011 : combine_indices
changes: add Group class

Notes
~~~~~

This reverses the class I used before, where the class was for the data and
the group was auxiliary. Here, it is only the group, no data is kept.

sparse_dummies needs checking for corner cases, e.g.
what if a category level has zero elements? This can happen with subset
    selection even if the original groups where defined as arange.

Not all methods and options have been tried out yet after refactoring

need more efficient loop if groups are sorted -> see GroupSorted.group_iter
"""
def combine_indices(groups, prefix=..., sep=..., return_labels=...): # -> tuple[_IntArray, _IntArray, ndarray[tuple[int, int], dtype[Any]] | NDArray[Any], list[str]] | tuple[_IntArray, _IntArray, ndarray[tuple[int, int], dtype[Any]] | NDArray[Any]]:
    """use np.unique to get integer group indices for product, intersection
    """
    ...

def group_sums(x, group, use_bincount=...): # -> NDArray[intp] | NDArray[float64]:
    """simple bincount version, again

    group : ndarray, integer
        assumed to be consecutive integers

    no dtype checking because I want to raise in that case

    uses loop over columns of x

    for comparison, simple python loop
    """
    ...

def group_sums_dummy(x, group_dummy): # -> Any:
    """sum by groups given group dummy variable

    group_dummy can be either ndarray or sparse matrix
    """
    ...

def dummy_sparse(groups): # -> csr_matrix:
    """create a sparse indicator from a group array with integer labels

    Parameters
    ----------
    groups : ndarray, int, 1d (nobs,)
        an array of group indicators for each observation. Group levels are
        assumed to be defined as consecutive integers, i.e. range(n_groups)
        where n_groups is the number of group levels. A group level with no
        observations for it will still produce a column of zeros.

    Returns
    -------
    indi : ndarray, int8, 2d (nobs, n_groups)
        an indicator array with one row per observation, that has 1 in the
        column of the group level for that observation

    Examples
    --------

    >>> g = np.array([0, 0, 2, 1, 1, 2, 0])
    >>> indi = dummy_sparse(g)
    >>> indi
    <7x3 sparse matrix of type '<type 'numpy.int8'>'
        with 7 stored elements in Compressed Sparse Row format>
    >>> indi.todense()
    matrix([[1, 0, 0],
            [1, 0, 0],
            [0, 0, 1],
            [0, 1, 0],
            [0, 1, 0],
            [0, 0, 1],
            [1, 0, 0]], dtype=int8)


    current behavior with missing groups
    >>> g = np.array([0, 0, 2, 0, 2, 0])
    >>> indi = dummy_sparse(g)
    >>> indi.todense()
    matrix([[1, 0, 0],
            [1, 0, 0],
            [0, 0, 1],
            [1, 0, 0],
            [0, 0, 1],
            [1, 0, 0]], dtype=int8)
    """
    ...

class Group:
    def __init__(self, group, name=...) -> None:
        ...

    def counts(self): # -> NDArray[intp]:
        ...

    def labels(self): # -> list[str] | list[str | Any]:
        ...

    def dummy(self, drop_idx=..., sparse=..., dtype=...): # -> csr_matrix:
        """
        drop_idx is only available if sparse=False

        drop_idx is supposed to index into uni
        """
        ...

    def interaction(self, other): # -> Self:
        ...

    def group_sums(self, x, use_bincount=...): # -> NDArray[intp] | NDArray[float64]:
        ...

    def group_demean(self, x, use_bincount=...): # -> tuple[Any, NDArray[intp] | NDArray[float64]]:
        ...



class GroupSorted(Group):
    def __init__(self, group, name=...) -> None:
        ...

    def group_iter(self): # -> Generator[slice[Any, Any, Any], Any, None]:
        ...

    def lag_indices(self, lag):
        """return the index array for lagged values

        Warning: if k is larger then the number of observations for an
        individual, then no values for that individual are returned.

        TODO: for the unbalanced case, I should get the same truncation for
        the array with lag=0. From the return of lag_idx we would not know
        which individual is missing.

        TODO: do I want the full equivalent of lagmat in tsa?
        maxlag or lag or lags.

        not tested yet
        """
        ...



class Grouping:
    def __init__(self, index, names=...) -> None:
        """
        index : index-like
            Can be pandas MultiIndex or Index or array-like. If array-like
            and is a MultipleIndex (more than one grouping variable),
            groups are expected to be in each row. E.g., [('red', 1),
            ('red', 2), ('green', 1), ('green', 2)]
        names : list or str, optional
            The names to use for the groups. Should be a str if only
            one grouping variable is used.

        Notes
        -----
        If index is already a pandas Index then there is no copy.
        """
        ...

    @property
    def index_shape(self): # -> Shape:
        ...

    @property
    def levels(self): # -> FrozenList:
        ...

    @property
    def labels(self): # -> ndarray[_AnyShape, dtype[Any]] | Any:
        ...

    @property
    def group_names(self): # -> Any:
        ...

    def reindex(self, index=..., names=...): # -> None:
        """
        Resets the index in-place.
        """
        ...

    def get_slices(self, level=...): # -> None:
        """
        Sets the slices attribute to be a list of indices of the sorted
        groups for the first index level. I.e., self.slices[0] is the
        index where each observation is in the first (sorted) group.
        """
        ...

    def count_categories(self, level=...): # -> None:
        """
        Sets the attribute counts to equal the bincount of the (integer-valued)
        labels.
        """
        ...

    def check_index(self, is_sorted=..., unique=..., index=...): # -> None:
        """Sanity checks"""
        ...

    def sort(self, data, index=...): # -> tuple[NDArray[Any], Index | Any | MultiIndex | RangeIndex] | tuple[Any, Any]:
        """Applies a (potentially hierarchical) sort operation on a numpy array
        or pandas series/dataframe based on the grouping index or a
        user-supplied index.  Returns an object of the same type as the
        original data as well as the matching (sorted) Pandas index.
        """
        ...

    def transform_dataframe(self, dataframe, function, level=..., **kwargs): # -> _Array1D[Any] | NDArray[Any]:
        """Apply function to each column, by group
        Assumes that the dataframe already has a proper index"""
        ...

    def transform_array(self, array, function, level=..., **kwargs): # -> _Array1D[Any] | NDArray[Any]:
        """Apply function to each column, by group
        """
        ...

    def transform_slices(self, array, function, level=..., **kwargs): # -> ndarray[tuple[int, int], dtype[Any]]:
        """Apply function to each group. Similar to transform_array but does
        not coerce array to a DataFrame and back and only works on a 1D or 2D
        numpy array. function is called function(group, group_idx, **kwargs).
        """
        ...

    def dummies_time(self): # -> csr_matrix:
        ...

    def dummies_groups(self, level=...): # -> csr_matrix:
        ...

    def dummy_sparse(self, level=...): # -> None:
        """create a sparse indicator from a group array with integer labels

        Parameters
        ----------
        groups : ndarray, int, 1d (nobs,)
            An array of group indicators for each observation. Group levels
            are assumed to be defined as consecutive integers, i.e.
            range(n_groups) where n_groups is the number of group levels.
            A group level with no observations for it will still produce a
            column of zeros.

        Returns
        -------
        indi : ndarray, int8, 2d (nobs, n_groups)
            an indicator array with one row per observation, that has 1 in the
            column of the group level for that observation

        Examples
        --------

        >>> g = np.array([0, 0, 2, 1, 1, 2, 0])
        >>> indi = dummy_sparse(g)
        >>> indi
        <7x3 sparse matrix of type '<type 'numpy.int8'>'
            with 7 stored elements in Compressed Sparse Row format>
        >>> indi.todense()
        matrix([[1, 0, 0],
                [1, 0, 0],
                [0, 0, 1],
                [0, 1, 0],
                [0, 1, 0],
                [0, 0, 1],
                [1, 0, 0]], dtype=int8)


        current behavior with missing groups
        >>> g = np.array([0, 0, 2, 0, 2, 0])
        >>> indi = dummy_sparse(g)
        >>> indi.todense()
        matrix([[1, 0, 0],
                [1, 0, 0],
                [0, 0, 1],
                [1, 0, 0],
                [0, 0, 1],
                [1, 0, 0]], dtype=int8)
        """
        ...
