

from io import BytesIO
import sys
from typing import Iterator
from . import dpkt

"""Libpcap file format."""
TCPDUMP_MAGIC = ...
TCPDUMP_MAGIC_NANO = ...
MODPCAP_MAGIC = ...
PMUDPCT_MAGIC = ...
PMUDPCT_MAGIC_NANO = ...
PACPDOM_MAGIC = ...
PCAP_VERSION_MAJOR = ...
PCAP_VERSION_MINOR = ...
DLT_NULL = ...
DLT_EN10MB = ...
DLT_EN3MB = ...
DLT_AX25 = ...
DLT_PRONET = ...
DLT_CHAOS = ...
DLT_IEEE802 = ...
DLT_ARCNET = ...
DLT_SLIP = ...
DLT_PPP = ...
DLT_FDDI = ...
DLT_PFSYNC = ...
DLT_PPP_SERIAL = ...
DLT_PPP_ETHER = ...
DLT_ATM_RFC1483 = ...
DLT_RAW = ...
DLT_C_HDLC = ...
DLT_IEEE802_11 = ...
DLT_FRELAY = ...
DLT_LOOP = ...
DLT_LINUX_SLL = ...
DLT_LTALK = ...
DLT_PFLOG = ...
DLT_PRISM_HEADER = ...
DLT_IP_OVER_FC = ...
DLT_SUNATM = ...
DLT_IEEE802_11_RADIO = ...
DLT_ARCNET_LINUX = ...
DLT_APPLE_IP_OVER_IEEE1394 = ...
DLT_MTP2_WITH_PHDR = ...
DLT_MTP2 = ...
DLT_MTP3 = ...
DLT_SCCP = ...
DLT_DOCSIS = ...
DLT_LINUX_IRDA = ...
DLT_USER0 = ...
DLT_USER1 = ...
DLT_USER2 = ...
DLT_USER3 = ...
DLT_USER4 = ...
DLT_USER5 = ...
DLT_USER6 = ...
DLT_USER7 = ...
DLT_USER8 = ...
DLT_USER9 = ...
DLT_USER10 = ...
DLT_USER11 = ...
DLT_USER12 = ...
DLT_USER13 = ...
DLT_USER14 = ...
DLT_USER15 = ...
DLT_IEEE802_11_RADIO_AVS = ...
DLT_BACNET_MS_TP = ...
DLT_PPP_PPPD = ...
DLT_GPRS_LLC = ...
DLT_GPF_T = ...
DLT_GPF_F = ...
DLT_LINUX_LAPD = ...
DLT_BLUETOOTH_HCI_H4 = ...
DLT_USB_LINUX = ...
DLT_PPI = ...
DLT_IEEE802_15_4 = ...
DLT_SITA = ...
DLT_ERF = ...
DLT_BLUETOOTH_HCI_H4_WITH_PHDR = ...
DLT_AX25_KISS = ...
DLT_LAPD = ...
DLT_PPP_WITH_DIR = ...
DLT_C_HDLC_WITH_DIR = ...
DLT_FRELAY_WITH_DIR = ...
DLT_IPMB_LINUX = ...
DLT_IEEE802_15_4_NONASK_PHY = ...
DLT_USB_LINUX_MMAPPED = ...
DLT_FC_2 = ...
DLT_FC_2_WITH_FRAME_DELIMS = ...
DLT_IPNET = ...
DLT_CAN_SOCKETCAN = ...
DLT_IPV4 = ...
DLT_IPV6 = ...
DLT_IEEE802_15_4_NOFCS = ...
DLT_DBUS = ...
DLT_DVB_CI = ...
DLT_MUX27010 = ...
DLT_STANAG_5066_D_PDU = ...
DLT_NFLOG = ...
DLT_NETANALYZER = ...
DLT_NETANALYZER_TRANSPARENT = ...
DLT_IPOIB = ...
DLT_MPEG_2_TS = ...
DLT_NG40 = ...
DLT_NFC_LLCP = ...
DLT_INFINIBAND = ...
DLT_SCTP = ...
DLT_USBPCAP = ...
DLT_RTAC_SERIAL = ...
DLT_BLUETOOTH_LE_LL = ...
DLT_NETLINK = ...
DLT_BLUETOOTH_LINUX_MONITOR = ...
DLT_BLUETOOTH_BREDR_BB = ...
DLT_BLUETOOTH_LE_LL_WITH_PHDR = ...
DLT_PROFIBUS_DL = ...
DLT_PKTAP = ...
DLT_EPON = ...
DLT_IPMI_HPM_2 = ...
DLT_ZWAVE_R1_R2 = ...
DLT_ZWAVE_R3 = ...
DLT_WATTSTOPPER_DLM = ...
DLT_ISO_14443 = ...
DLT_LINUX_SLL2 = ...
if sys.platform.find('openbsd') != -1:
    DLT_LOOP = ...
    DLT_RAW = ...
else:
    DLT_LOOP = ...
    DLT_RAW = ...
dltoff = ...
class PktHdr(dpkt.Packet):

    __hdr__ = ...


class PktModHdr(dpkt.Packet):

    __hdr__ = ...


class LEPktHdr(PktHdr):
    __byte_order__ = ...


class LEPktModHdr(PktModHdr):
    __byte_order__ = ...


MAGIC_TO_PKT_HDR = ...
class FileHdr(dpkt.Packet):

    __hdr__ = ...


class LEFileHdr(FileHdr):
    __byte_order__ = ...


class Writer:

    __le = ...
    def __init__(self, fileobj, snaplen=..., linktype=..., nano=...) -> None:
        ...

    def writepkt(self, pkt, ts=...): # -> None:

        ...

    def writepkt_time(self, pkt, ts): # -> None:

        ...

    def writepkts(self, pkts): # -> None:

        ...

    def close(self): # -> None:
        ...



class Reader:

    def __init__(self, fileobj: BytesIO) -> None:
        ...

    @property
    def fd(self) -> int:
        ...

    def fileno(self) -> int:
        ...

    def datalink(self):
        ...

    def setfilter(self, value, optimize=...):
        ...

    def readpkts(self) -> list[tuple[float, bytes]]:
        ...

    def __next__(self) -> tuple[float, bytes]:
        ...

    next = ...
    def dispatch(self, cnt, callback, *args): # -> int:

        ...

    def loop(self, callback, *args): # -> None:
        ...

    def __iter__(self) -> Iterator[tuple[float, bytes]]:
        ...



class UniversalReader:

    def __new__(cls, fileobj): # -> dpkt.pcap.Reader | dpkt.pcapng.Reader:
        ...



class TryExceptException:
    def __init__(self, exception_type, msg=...) -> None:
        ...

    def __call__(self, f, *args, **kwargs): # -> Callable[..., None]:
        ...



@TryExceptException(Exception, msg='There should have been an Exception raised')
def test_TryExceptException(): # -> None:

    ...

def test_pcap_endian(): # -> None:
    ...

class TestData:
    pcap = ...
    modified_pcap = ...


def test_reader(): # -> None:
    class Count:
        ...



def test_reader_dloff(): # -> None:
    ...

@TryExceptException(ValueError, msg="invalid tcpdump header")
def test_reader_badheader(): # -> None:
    ...

def test_reader_fd(): # -> None:
    ...

def test_reader_modified_pcap_type(): # -> None:
    ...

class WriterTestWrap:

    def __init__(self, *args, **kwargs) -> None:
        ...

    def __call__(self, f, *args, **kwargs): # -> Callable[..., None]:
        ...



@WriterTestWrap()
def test_writer_precision_normal(): # -> list[tuple[float, bytes]]:
    ...

@WriterTestWrap(writer={ 'nano': True })
def test_writer_precision_nano(): # -> list[tuple[Decimal, bytes]]:
    ...

@WriterTestWrap(writer={ 'nano': False })
def test_writer_precision_nano_fail(): # -> list[tuple[float, bytes]]:

    ...

@WriterTestWrap()
def test_writepkt_no_time(): # -> list[tuple[float, bytes]]:
    ...

@WriterTestWrap(writer={ 'snaplen': 10 })
def test_writepkt_snaplen(): # -> list[tuple[float, bytes]]:
    ...

@WriterTestWrap()
def test_writepkt_with_time(): # -> list[tuple[float, bytes]]:
    ...

@WriterTestWrap()
def test_writepkt_time(): # -> list[tuple[float, bytes]]:
    ...

@WriterTestWrap()
def test_writepkts(): # -> list[tuple[float, bytes]]:

    ...

def test_universal_reader(): # -> None:
    ...
