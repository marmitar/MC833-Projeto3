"""
This type stub file was generated by pyright.
"""

import sys
from . import dpkt

"""Libpcap file format."""
TCPDUMP_MAGIC = ...
TCPDUMP_MAGIC_NANO = ...
MODPCAP_MAGIC = ...
PMUDPCT_MAGIC = ...
PMUDPCT_MAGIC_NANO = ...
PACPDOM_MAGIC = ...
PCAP_VERSION_MAJOR = ...
PCAP_VERSION_MINOR = ...
DLT_NULL = ...
DLT_EN10MB = ...
DLT_EN3MB = ...
DLT_AX25 = ...
DLT_PRONET = ...
DLT_CHAOS = ...
DLT_IEEE802 = ...
DLT_ARCNET = ...
DLT_SLIP = ...
DLT_PPP = ...
DLT_FDDI = ...
DLT_PFSYNC = ...
DLT_PPP_SERIAL = ...
DLT_PPP_ETHER = ...
DLT_ATM_RFC1483 = ...
DLT_RAW = ...
DLT_C_HDLC = ...
DLT_IEEE802_11 = ...
DLT_FRELAY = ...
DLT_LOOP = ...
DLT_LINUX_SLL = ...
DLT_LTALK = ...
DLT_PFLOG = ...
DLT_PRISM_HEADER = ...
DLT_IP_OVER_FC = ...
DLT_SUNATM = ...
DLT_IEEE802_11_RADIO = ...
DLT_ARCNET_LINUX = ...
DLT_APPLE_IP_OVER_IEEE1394 = ...
DLT_MTP2_WITH_PHDR = ...
DLT_MTP2 = ...
DLT_MTP3 = ...
DLT_SCCP = ...
DLT_DOCSIS = ...
DLT_LINUX_IRDA = ...
DLT_USER0 = ...
DLT_USER1 = ...
DLT_USER2 = ...
DLT_USER3 = ...
DLT_USER4 = ...
DLT_USER5 = ...
DLT_USER6 = ...
DLT_USER7 = ...
DLT_USER8 = ...
DLT_USER9 = ...
DLT_USER10 = ...
DLT_USER11 = ...
DLT_USER12 = ...
DLT_USER13 = ...
DLT_USER14 = ...
DLT_USER15 = ...
DLT_IEEE802_11_RADIO_AVS = ...
DLT_BACNET_MS_TP = ...
DLT_PPP_PPPD = ...
DLT_GPRS_LLC = ...
DLT_GPF_T = ...
DLT_GPF_F = ...
DLT_LINUX_LAPD = ...
DLT_BLUETOOTH_HCI_H4 = ...
DLT_USB_LINUX = ...
DLT_PPI = ...
DLT_IEEE802_15_4 = ...
DLT_SITA = ...
DLT_ERF = ...
DLT_BLUETOOTH_HCI_H4_WITH_PHDR = ...
DLT_AX25_KISS = ...
DLT_LAPD = ...
DLT_PPP_WITH_DIR = ...
DLT_C_HDLC_WITH_DIR = ...
DLT_FRELAY_WITH_DIR = ...
DLT_IPMB_LINUX = ...
DLT_IEEE802_15_4_NONASK_PHY = ...
DLT_USB_LINUX_MMAPPED = ...
DLT_FC_2 = ...
DLT_FC_2_WITH_FRAME_DELIMS = ...
DLT_IPNET = ...
DLT_CAN_SOCKETCAN = ...
DLT_IPV4 = ...
DLT_IPV6 = ...
DLT_IEEE802_15_4_NOFCS = ...
DLT_DBUS = ...
DLT_DVB_CI = ...
DLT_MUX27010 = ...
DLT_STANAG_5066_D_PDU = ...
DLT_NFLOG = ...
DLT_NETANALYZER = ...
DLT_NETANALYZER_TRANSPARENT = ...
DLT_IPOIB = ...
DLT_MPEG_2_TS = ...
DLT_NG40 = ...
DLT_NFC_LLCP = ...
DLT_INFINIBAND = ...
DLT_SCTP = ...
DLT_USBPCAP = ...
DLT_RTAC_SERIAL = ...
DLT_BLUETOOTH_LE_LL = ...
DLT_NETLINK = ...
DLT_BLUETOOTH_LINUX_MONITOR = ...
DLT_BLUETOOTH_BREDR_BB = ...
DLT_BLUETOOTH_LE_LL_WITH_PHDR = ...
DLT_PROFIBUS_DL = ...
DLT_PKTAP = ...
DLT_EPON = ...
DLT_IPMI_HPM_2 = ...
DLT_ZWAVE_R1_R2 = ...
DLT_ZWAVE_R3 = ...
DLT_WATTSTOPPER_DLM = ...
DLT_ISO_14443 = ...
DLT_LINUX_SLL2 = ...
if sys.platform.find('openbsd') != -1:
    DLT_LOOP = ...
    DLT_RAW = ...
else:
    DLT_LOOP = ...
    DLT_RAW = ...
dltoff = ...
class PktHdr(dpkt.Packet):
    """pcap packet header.

    TODO: Longer class information....

    Attributes:
        __hdr__: Header fields of pcap header.
        TODO.
    """
    __hdr__ = ...


class PktModHdr(dpkt.Packet):
    """modified pcap packet header.
    https://wiki.wireshark.org/Development/LibpcapFileFormat#modified-pcap

    TODO: Longer class information....

    Attributes:
        __hdr__: Header fields of pcap header.
        TODO.
    """
    __hdr__ = ...


class LEPktHdr(PktHdr):
    __byte_order__ = ...


class LEPktModHdr(PktModHdr):
    __byte_order__ = ...


MAGIC_TO_PKT_HDR = ...
class FileHdr(dpkt.Packet):
    """pcap file header.

    TODO: Longer class information....

    Attributes:
        __hdr__: Header fields of pcap file header.
        TODO.
    """
    __hdr__ = ...


class LEFileHdr(FileHdr):
    __byte_order__ = ...


class Writer:
    """Simple pcap dumpfile writer.

    TODO: Longer class information....

    Attributes:
        __hdr__: Header fields of simple pcap dumpfile writer.
        TODO.
    """
    __le = ...
    def __init__(self, fileobj, snaplen=..., linktype=..., nano=...) -> None:
        ...
    
    def writepkt(self, pkt, ts=...): # -> None:
        """Write single packet and optional timestamp to file.

        Args:
            pkt: `bytes` will be called on this and written to file.
            ts (float): Timestamp in seconds. Defaults to current time.
        """
        ...
    
    def writepkt_time(self, pkt, ts): # -> None:
        """Write single packet and its timestamp to file.

        Args:
            pkt (bytes): Some `bytes` to write to the file
            ts (float): Timestamp in seconds
        """
        ...
    
    def writepkts(self, pkts): # -> None:
        """Write an iterable of packets to file.

        Timestamps should be in seconds.
        Packets must be of type `bytes` as they will not be cast.

        Args:
            pkts: iterable containing (ts, pkt)
        """
        ...
    
    def close(self): # -> None:
        ...
    


class Reader:
    """Simple pypcap-compatible pcap file reader.

    TODO: Longer class information....

    Attributes:
        __hdr__: Header fields of simple pypcap-compatible pcap file reader.
        TODO.
    """
    def __init__(self, fileobj) -> None:
        ...
    
    @property
    def fd(self):
        ...
    
    def fileno(self):
        ...
    
    def datalink(self):
        ...
    
    def setfilter(self, value, optimize=...):
        ...
    
    def readpkts(self): # -> list[tuple[Any, Any]]:
        ...
    
    def __next__(self): # -> tuple[Any, Any]:
        ...
    
    next = ...
    def dispatch(self, cnt, callback, *args): # -> int:
        """Collect and process packets with a user callback.

        Return the number of packets processed, or 0 for a savefile.

        Arguments:

        cnt      -- number of packets to process;
                    or 0 to process all packets until EOF
        callback -- function with (timestamp, pkt, *args) prototype
        *args    -- optional arguments passed to callback on execution
        """
        ...
    
    def loop(self, callback, *args): # -> None:
        ...
    
    def __iter__(self): # -> Generator[tuple[Any, Any], Any, None]:
        ...
    


class UniversalReader:
    """
    Universal pcap reader for the libpcap and pcapng file formats
    """
    def __new__(cls, fileobj): # -> dpkt.pcap.Reader | dpkt.pcapng.Reader:
        ...
    


class TryExceptException:
    def __init__(self, exception_type, msg=...) -> None:
        ...
    
    def __call__(self, f, *args, **kwargs): # -> Callable[..., None]:
        ...
    


@TryExceptException(Exception, msg='There should have been an Exception raised')
def test_TryExceptException(): # -> None:
    """Check that we can catch a function which does not throw an exception when it is supposed to"""
    ...

def test_pcap_endian(): # -> None:
    ...

class TestData:
    pcap = ...
    modified_pcap = ...


def test_reader(): # -> None:
    class Count:
        ...
    
    

def test_reader_dloff(): # -> None:
    ...

@TryExceptException(ValueError, msg="invalid tcpdump header")
def test_reader_badheader(): # -> None:
    ...

def test_reader_fd(): # -> None:
    ...

def test_reader_modified_pcap_type(): # -> None:
    ...

class WriterTestWrap:
    """
    Decorate a writer test function with an instance of this class.

    The test will be provided with a writer object, which it should write some pkts to.

    After the test has run, the BytesIO object will be passed to a Reader,
    which will compare each pkt to the return value of the test.
    """
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def __call__(self, f, *args, **kwargs): # -> Callable[..., None]:
        ...
    


@WriterTestWrap()
def test_writer_precision_normal(): # -> list[tuple[float, bytes]]:
    ...

@WriterTestWrap(writer={ 'nano': True })
def test_writer_precision_nano(): # -> list[tuple[Decimal, bytes]]:
    ...

@WriterTestWrap(writer={ 'nano': False })
def test_writer_precision_nano_fail(): # -> list[tuple[float, bytes]]:
    """if writer is not set to nano, supplying this timestamp should be truncated"""
    ...

@WriterTestWrap()
def test_writepkt_no_time(): # -> list[tuple[float, bytes]]:
    ...

@WriterTestWrap(writer={ 'snaplen': 10 })
def test_writepkt_snaplen(): # -> list[tuple[float, bytes]]:
    ...

@WriterTestWrap()
def test_writepkt_with_time(): # -> list[tuple[float, bytes]]:
    ...

@WriterTestWrap()
def test_writepkt_time(): # -> list[tuple[float, bytes]]:
    ...

@WriterTestWrap()
def test_writepkts(): # -> list[tuple[float, bytes]]:
    """writing multiple packets from a list"""
    ...

def test_universal_reader(): # -> None:
    ...

