"""
This type stub file was generated by pyright.
"""

import sys
from . import dpkt

"""pcap Next Generation file format"""
BYTE_ORDER_MAGIC = ...
BYTE_ORDER_MAGIC_LE = ...
PCAPNG_VERSION_MAJOR = ...
PCAPNG_VERSION_MINOR = ...
PCAPNG_BT_IDB = ...
PCAPNG_BT_PB = ...
PCAPNG_BT_SPB = ...
PCAPNG_BT_EPB = ...
PCAPNG_BT_SHB = ...
PCAPNG_OPT_ENDOFOPT = ...
PCAPNG_OPT_COMMENT = ...
PCAPNG_OPT_SHB_HARDWARE = ...
PCAPNG_OPT_SHB_OS = ...
PCAPNG_OPT_SHB_USERAPPL = ...
PCAPNG_OPT_IF_NAME = ...
PCAPNG_OPT_IF_DESCRIPTION = ...
PCAPNG_OPT_IF_IPV4ADDR = ...
PCAPNG_OPT_IF_IPV6ADDR = ...
PCAPNG_OPT_IF_MACADDR = ...
PCAPNG_OPT_IF_EUIADDR = ...
PCAPNG_OPT_IF_SPEED = ...
PCAPNG_OPT_IF_TSRESOL = ...
PCAPNG_OPT_IF_TZONE = ...
PCAPNG_OPT_IF_FILTER = ...
PCAPNG_OPT_IF_OS = ...
PCAPNG_OPT_IF_FCSLEN = ...
PCAPNG_OPT_IF_TSOFFSET = ...
DLT_NULL = ...
DLT_EN10MB = ...
DLT_EN3MB = ...
DLT_AX25 = ...
DLT_PRONET = ...
DLT_CHAOS = ...
DLT_IEEE802 = ...
DLT_ARCNET = ...
DLT_SLIP = ...
DLT_PPP = ...
DLT_FDDI = ...
DLT_PFSYNC = ...
DLT_IEEE802_11 = ...
DLT_LINUX_SLL = ...
DLT_PFLOG = ...
DLT_IEEE802_11_RADIO = ...
if sys.platform.find('openbsd') != -1:
    DLT_LOOP = ...
    DLT_RAW = ...
else:
    DLT_LOOP = ...
    DLT_RAW = ...
dltoff = ...
class _PcapngBlock(dpkt.Packet):
    """Base class for a pcapng block with Options"""
    __hdr__ = ...
    def unpack_hdr(self, buf): # -> None:
        ...
    
    def unpack(self, buf): # -> None:
        ...
    
    def __bytes__(self): # -> bytes:
        ...
    
    def __len__(self):
        ...
    


class PcapngBlockLE(_PcapngBlock):
    __byte_order__ = ...


class PcapngOption(dpkt.Packet):
    """A single Option"""
    __hdr__ = ...
    def unpack(self, buf): # -> None:
        ...
    
    def __bytes__(self): # -> bytes:
        ...
    
    def __len__(self):
        ...
    
    def __repr__(self): # -> str:
        ...
    


class PcapngOptionLE(PcapngOption):
    __byte_order__ = ...


class SectionHeaderBlock(_PcapngBlock):
    """Section Header block"""
    __hdr__ = ...
    def __bytes__(self): # -> bytes:
        ...
    


class SectionHeaderBlockLE(SectionHeaderBlock):
    __byte_order__ = ...


class InterfaceDescriptionBlock(_PcapngBlock):
    """Interface Description block"""
    __hdr__ = ...
    def __bytes__(self): # -> bytes:
        ...
    


class InterfaceDescriptionBlockLE(InterfaceDescriptionBlock):
    __byte_order__ = ...


class EnhancedPacketBlock(_PcapngBlock):
    """Enhanced Packet block"""
    __hdr__ = ...
    def unpack(self, buf): # -> None:
        ...
    
    def __bytes__(self): # -> bytes:
        ...
    
    def __len__(self):
        ...
    


class EnhancedPacketBlockLE(EnhancedPacketBlock):
    __byte_order__ = ...


class PacketBlock(EnhancedPacketBlock):
    """Packet block (deprecated)"""
    __hdr__ = ...
    def __bytes__(self): # -> bytes:
        ...
    


class PacketBlockLE(PacketBlock):
    __byte_order__ = ...


class Writer:
    """Simple pcapng dumpfile writer."""
    __le = ...
    def __init__(self, fileobj, snaplen=..., linktype=..., shb=..., idb=...) -> None:
        """
        Create a pcapng dumpfile writer for the given fileobj.

        shb can be an instance of SectionHeaderBlock(LE)
        idb can be an instance of InterfaceDescriptionBlock(LE) (or sequence of them)
        """
        ...
    
    def writepkt(self, pkt, ts=...): # -> None:
        """
        Write a single packet with an optional timestamp.

        Args:
            pkt: buffer or instance of EnhancedPacketBlock(LE)
            ts: Unix timestamp in seconds since Epoch (e.g. 1454725786.99)
        """
        ...
    
    def writepkt_time(self, pkt, ts): # -> None:
        """
        Write a single packet with a mandatory timestamp.

        Args:
            pkt: a buffer
            ts: Unix timestamp in seconds since Epoch (e.g. 1454725786.99)
        """
        ...
    
    def writepkts(self, pkts): # -> None:
        """
        Take an iterable of (ts, pkt), and write to file.
        """
        ...
    
    def close(self): # -> None:
        ...
    


class Reader:
    """Simple pypcap-compatible pcapng file reader."""
    def __init__(self, fileobj) -> None:
        ...
    
    @property
    def fd(self):
        ...
    
    def fileno(self):
        ...
    
    def datalink(self):
        ...
    
    def setfilter(self, value, optimize=...):
        ...
    
    def readpkts(self): # -> list[tuple[Any, Any]]:
        ...
    
    def __next__(self): # -> tuple[Any, Any]:
        ...
    
    next = ...
    def dispatch(self, cnt, callback, *args): # -> int:
        """Collect and process packets with a user callback.

        Return the number of packets processed, or 0 for a savefile.

        Arguments:

        cnt      -- number of packets to process;
                    or 0 to process all packets until EOF
        callback -- function with (timestamp, pkt, *args) prototype
        *args    -- optional arguments passed to callback on execution
        """
        ...
    
    def loop(self, callback, *args): # -> None:
        ...
    
    def __iter__(self): # -> Generator[tuple[Any, Any], Any, None]:
        ...
    


def test_shb(): # -> None:
    """Test SHB with options"""
    ...

def test_idb(): # -> None:
    """Test IDB with options"""
    ...

def test_epb(): # -> None:
    """Test EPB with a non-ascii comment option"""
    ...

def test_pb(): # -> None:
    """Test PB with a non-ascii comment option"""
    ...

def test_pb_read(): # -> None:
    """ Test PB parsing as part of file """
    ...

def test_epb_ascii_comment_option(): # -> None:
    """Test EPB with an ascii comment option"""
    ...

def test_epb_invalid_utf8_comment_option(): # -> None:
    """Test EPB with an invalid (non UTF-8, non-zero terminated ascii) comment option"""
    ...

def test_simple_write_read(): # -> None:
    """Test writing a basic pcapng and then reading it"""
    ...

def test_pcapng_header(): # -> None:
    """Reading an empty file will fail as the header length is incorrect"""
    ...

def define_testdata(): # -> TestData:
    class TestData:
        ...
    
    

def pre_test(f): # -> Callable[..., Any]:
    ...

class WriterTestWrap:
    """
    Decorate a writer test function with an instance of this class.

    The test will be provided with a writer object, which it should write some pkts to.

    After the test has run, the BytesIO object will be passed to a Reader,
    which will compare each pkt to the return value of the test.
    """
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def __call__(self, f, *args, **kwargs): # -> Callable[..., None]:
        ...
    


class PostTest:
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def __call__(self, f, *args, **kwargs): # -> Callable[..., None]:
        ...
    


@PostTest(test='assertion', type=ValueError, msg='invalid pcapng header: not a SHB')
@pre_test
def test_shb_header(): # -> None:
    ...

@PostTest(test='assertion', type=ValueError, msg='unknown endianness')
@pre_test
def test_shb_bom(): # -> None:
    ...

@PostTest(test='assertion', type=ValueError, msg='unknown pcapng version 123.45')
@pre_test
def test_shb_version(): # -> None:
    ...

@PostTest(test='assertion', type=ValueError, msg='IDB not found')
@pre_test
def test_no_idb(): # -> None:
    ...

@PostTest(test='compare_property', property='idb')
@pre_test
def test_idb_opt_offset(): # -> InterfaceDescriptionBlockLE:
    """Test that the timestamp offset is correctly written and read"""
    ...

@PostTest(test='compare_property', property='dloff')
@pre_test
def test_idb_linktype(): # -> Literal[0]:
    """Test that if the idb.linktype is not in dloff, dloff is set to 0"""
    ...

def test_repr(): # -> None:
    """check the __repr__ method for Packet subclass.

    The __repr__ method currently includes the b'' in the string. This means that python2 and python3 will differ.
    """
    ...

@pre_test
def test_filter(): # -> None:
    ...

@PostTest(test='compare_method', method='readpkts')
@pre_test
def test_readpkts(): # -> list[tuple[float, bytes]]:
    ...

@PostTest(test='compare_method', method='next')
@pre_test
def test_next(): # -> tuple[float, bytes]:
    ...

@pre_test
def test_dispatch(): # -> None:
    ...

@pre_test
def test_loop(): # -> None:
    ...

def test_idb_opt_err(): # -> None:
    """Test that options end with opt_endofopt"""
    ...

def test_custom_read_write(): # -> None:
    """Test a full pcapng file with 1 ICMP packet"""
    ...

def test_multi_idb_writer(): # -> None:
    """Test writing multiple interface description blocks into pcapng and read it"""
    ...

@pre_test
def test_writer_validate_instance(): # -> None:
    """System endianness and shb endianness should match"""
    ...

@pre_test
def test_writepkt_epb_ts(): # -> None:
    """writepkt should assign ts_high/low for epb if they are 0"""
    ...

@pre_test
def test_writer_validate_le(): # -> None:
    """System endianness and shb endianness should match"""
    ...

@pre_test
def test_writer_validate_be(): # -> None:
    """System endianness and shb endianness should match"""
    ...

@WriterTestWrap()
def test_writepkt_no_time(): # -> list[tuple[float, bytes]]:
    ...

@WriterTestWrap(writer={ 'snaplen': 10 })
def test_writepkt_snaplen(): # -> list[tuple[float, bytes]]:
    ...

@WriterTestWrap()
def test_writepkt_with_time(): # -> list[tuple[float, bytes]]:
    ...

@WriterTestWrap()
def test_writepkts(): # -> list[tuple[float, bytes]]:
    """writing multiple packets from a list"""
    ...

def test_pcapng_block_pack(): # -> None:
    ...

def test_pcapng_block_unpack(): # -> None:
    ...

def test_epb_unpack(): # -> None:
    """EnhancedPacketBlock can only unpack data >64 bytes, the length of their header"""
    ...

def test_epb_unpack_length_mismatch(): # -> None:
    """Force calculated len to be 0 when unpacking epb, this should fail when unpacking"""
    ...

def test_pcapng_block_len_no_opts(): # -> None:
    """_PcapngBlock should return its own header __len__ if it has no opts"""
    ...

def test_reader_file_descriptor(): # -> None:
    """Reader has .fd and .fileno() convenience members. Compare them to the actual fobj that was passed in"""
    ...

def test_posttest(): # -> None:
    """Check that PostTest wrapper doesn't fail silently"""
    ...

