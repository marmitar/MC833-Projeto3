"""
This type stub file was generated by pyright.
"""

from . import dpkt

"""Secure Sockets Layer / Transport Layer Security."""
class SSL2(dpkt.Packet):
    __hdr__ = ...
    def unpack(self, buf): # -> None:
        ...
    


class TLS(dpkt.Packet):
    __hdr__ = ...
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def unpack(self, buf): # -> None:
        ...
    


SSL3_V = ...
TLS1_V = ...
TLS11_V = ...
TLS12_V = ...
ssl3_versions_str = ...
SSL3_VERSION_BYTES = ...
SSL3_AD_WARNING = ...
SSL3_AD_FATAL = ...
alert_level_str = ...
SSL3_AD_CLOSE_NOTIFY = ...
SSL3_AD_UNEXPECTED_MESSAGE = ...
SSL3_AD_BAD_RECORD_MAC = ...
SSL3_AD_DECOMPRESSION_FAILURE = ...
SSL3_AD_HANDSHAKE_FAILURE = ...
SSL3_AD_NO_CERTIFICATE = ...
SSL3_AD_BAD_CERTIFICATE = ...
SSL3_AD_UNSUPPORTED_CERTIFICATE = ...
SSL3_AD_CERTIFICATE_REVOKED = ...
SSL3_AD_CERTIFICATE_EXPIRED = ...
SSL3_AD_CERTIFICATE_UNKNOWN = ...
SSL3_AD_ILLEGAL_PARAMETER = ...
TLS1_AD_DECRYPTION_FAILED = ...
TLS1_AD_RECORD_OVERFLOW = ...
TLS1_AD_UNKNOWN_CA = ...
TLS1_AD_ACCESS_DENIED = ...
TLS1_AD_DECODE_ERROR = ...
TLS1_AD_DECRYPT_ERROR = ...
TLS1_AD_EXPORT_RESTRICTION = ...
TLS1_AD_PROTOCOL_VERSION = ...
TLS1_AD_INSUFFICIENT_SECURITY = ...
TLS1_AD_INTERNAL_ERROR = ...
TLS1_AD_USER_CANCELLED = ...
TLS1_AD_NO_RENEGOTIATION = ...
TLS1_AD_UNSUPPORTED_EXTENSION = ...
TLS1_AD_CERTIFICATE_UNOBTAINABLE = ...
TLS1_AD_UNRECOGNIZED_NAME = ...
TLS1_AD_BAD_CERTIFICATE_STATUS_RESPONSE = ...
TLS1_AD_BAD_CERTIFICATE_HASH_VALUE = ...
TLS1_AD_UNKNOWN_PSK_IDENTITY = ...
alert_description_str = ...
_SIZE_FORMATS = ...
def parse_variable_array(buf, lenbytes): # -> tuple[Any, Any]:
    """
    Parse an array described using the 'Type name<x..y>' syntax from the spec
    Read a length at the start of buf, and returns that many bytes
    after, in a tuple with the TOTAL bytes consumed (including the size). This
    does not check that the array is the right length for any given datatype.
    """
    ...

def parse_extensions(buf): # -> list[Any]:
    """
    Parse TLS extensions in passed buf. Returns an ordered list of extension tuples with
    ordinal extension type as first value and extension data as second value.
    Passed buf must start with the 2-byte extensions length TLV.
    http://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml
    """
    ...

class SSL3Exception(Exception):
    ...


class TLSRecord(dpkt.Packet):
    """
    SSLv3 or TLSv1+ packet.

    In addition to the fields specified in the header, there are
    compressed and decrypted fields, indicating whether, in the language
    of the spec, this is a TLSPlaintext, TLSCompressed, or
    TLSCiphertext. The application will have to figure out when it's
    appropriate to change these values.
    """
    __hdr__ = ...
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def unpack(self, buf): # -> None:
        ...
    


class TLSChangeCipherSpec(dpkt.Packet):
    """
    ChangeCipherSpec message is just a single byte with value 1
    """
    __hdr__ = ...


class TLSAppData(str):
    """
    As far as TLSRecord is concerned, AppData is just an opaque blob.
    """
    ...


class TLSAlert(dpkt.Packet):
    __hdr__ = ...


class TLSHelloRequest(dpkt.Packet):
    __hdr__ = ...


class TLSClientHello(dpkt.Packet):
    __hdr__ = ...
    def unpack(self, buf): # -> None:
        ...
    


class TLSServerHello(dpkt.Packet):
    __hdr__ = ...
    def unpack(self, buf): # -> None:
        ...
    
    @property
    def cipher_suite(self): # -> CipherSuite:
        ...
    
    @property
    def compression(self): # -> Any:
        ...
    


class TLSCertificate(dpkt.Packet):
    __hdr__ = ...
    def unpack(self, buf): # -> None:
        ...
    


class TLSUnknownHandshake(dpkt.Packet):
    __hdr__ = ...


TLSNewSessionTicket = TLSUnknownHandshake
TLSServerKeyExchange = TLSUnknownHandshake
TLSCertificateRequest = TLSUnknownHandshake
TLSServerHelloDone = TLSUnknownHandshake
TLSCertificateVerify = TLSUnknownHandshake
TLSClientKeyExchange = TLSUnknownHandshake
TLSFinished = TLSUnknownHandshake
HANDSHAKE_TYPES = ...
class TLSHandshake(dpkt.Packet):
    """
    A TLS Handshake message

    This goes for all messages encapsulated in the Record layer, but especially
    important for handshakes and app data: A message may be spread across a
    number of TLSRecords, in addition to the possibility of there being more
    than one in a given Record. You have to put together the contents of
    TLSRecord's yourself.
    """
    __hdr__ = ...
    __pprint_funcs__ = ...
    def unpack(self, buf): # -> None:
        ...
    
    @property
    def length(self): # -> Any:
        ...
    


RECORD_TYPES = ...
class SSLFactory:
    def __new__(cls, buf): # -> TLSRecord | SSL2:
        ...
    


def tls_multi_factory(buf): # -> tuple[list[Any], int]:
    """
    Attempt to parse one or more TLSRecord's out of buf

    Args:
      buf: string containing SSL/TLS messages. May have an incomplete record
        on the end

    Returns:
      [TLSRecord]
      int, total bytes consumed, != len(buf) if an incomplete record was left at
        the end.

    Raises SSL3Exception.
    """
    ...

_hexdecode = ...
class TestTLS:
    """
    Test basic TLS functionality.
    Test that each TLSRecord is correctly discovered and added to TLS.records
    """
    @classmethod
    def setup_class(cls): # -> None:
        ...
    
    def test_records_length(self): # -> None:
        ...
    
    def test_record_type(self): # -> None:
        ...
    
    def test_record_version(self): # -> None:
        ...
    


class TestTLSRecord:
    """
    Test basic TLSRecord functionality
    For this test, the contents of the record doesn't matter, since we're not parsing the next layer.
    """
    @classmethod
    def setup_class(cls): # -> None:
        ...
    
    def test_content_type(self): # -> None:
        ...
    
    def test_version(self): # -> None:
        ...
    
    def test_length(self): # -> None:
        ...
    
    def test_data(self): # -> None:
        ...
    
    def test_initial_flags(self): # -> None:
        ...
    
    def test_repack(self): # -> None:
        ...
    
    def test_total_length(self): # -> None:
        ...
    
    def test_raises_need_data_when_buf_is_short(self): # -> None:
        ...
    


class TestTLSChangeCipherSpec:
    """It's just a byte. This will be quick, I promise"""
    @classmethod
    def setup_class(cls): # -> None:
        ...
    
    def test_parses(self): # -> None:
        ...
    
    def test_total_length(self): # -> None:
        ...
    


class TestTLSAppData:
    """AppData is basically just a string"""
    def test_value(self): # -> None:
        ...
    


class TestTLSHandshake:
    @classmethod
    def setup_class(cls): # -> None:
        ...
    
    def test_created_inside_message(self): # -> None:
        ...
    
    def test_length(self): # -> None:
        ...
    
    def test_raises_need_data(self): # -> None:
        ...
    


class TestClientHello:
    """This data is extracted from and verified by Wireshark"""
    @classmethod
    def setup_class(cls): # -> None:
        ...
    
    def test_client_hello_constructed(self): # -> None:
        """Make sure the correct class was constructed"""
        ...
    
    def test_client_random_correct(self): # -> None:
        ...
    
    def test_ciphersuites(self): # -> None:
        ...
    
    def test_session_id(self): # -> None:
        ...
    
    def test_compression_methods(self): # -> None:
        ...
    
    def test_total_length(self): # -> None:
        ...
    


class TestServerHello:
    """Again, from Wireshark"""
    @classmethod
    def setup_class(cls): # -> None:
        ...
    
    def test_constructed(self): # -> None:
        ...
    
    def test_random_correct(self): # -> None:
        ...
    
    def test_ciphersuite(self): # -> None:
        ...
    
    def test_compression_method(self): # -> None:
        ...
    
    def test_total_length(self): # -> None:
        ...
    


class TestTLSCertificate:
    """We use a 2016 certificate record from iana.org as test data."""
    @classmethod
    def setup_class(cls): # -> None:
        ...
    
    def test_num_certs(self): # -> None:
        ...
    


class TestTLSMultiFactory:
    """Made up test data"""
    @classmethod
    def setup_class(cls): # -> None:
        ...
    
    def test_num_messages(self): # -> None:
        ...
    
    def test_bytes_parsed(self): # -> None:
        ...
    
    def test_first_msg_data(self): # -> None:
        ...
    
    def test_second_msg_data(self): # -> None:
        ...
    
    def test_incomplete(self): # -> None:
        ...
    


def test_ssl2(): # -> None:
    ...

def test_clienthello_invalidcipher(): # -> None:
    ...

def test_serverhello_invalidcipher(): # -> None:
    ...

def test_tlscertificate_unpacking_error(): # -> None:
    ...

def test_tlshandshake_invalid_type(): # -> None:
    ...

def test_sslfactory(): # -> None:
    ...

def test_extensions(): # -> None:
    ...

